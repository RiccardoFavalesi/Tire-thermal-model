function result = nsga2(opt, varargin)
% Function: result = nsga2(opt, varargin)
% Description: The main flowchart of of NSGA-II. Note:
%   All objectives must be minimization. If a objective is maximization, the
%   objective should be multipled by -1.
%
% Syntax:
%   result = nsga2(opt): 'opt' is generated by function nsgaopt().
%   result = nsga2(opt, param): 'param' can be any data type, it will be
%       pass to the objective function objfun().
%
%   Then ,the result structure can be pass to plotnsga to display the
%   population:  plotnsga(result);
%
% Parameters:
%   opt : A structure generated by funciton nsgaopt().
%   varargin : Additional parameter will be pass to the objective functions.
%       It can be any data type. For example, if you call: nsga2(opt, param),
%       then objfun would be called as objfun(x,param), in which, x is the
%       design variables vector.
% Return:
%   result : A structure contains optimization result.
%
%         LSSSSWC, NWPU
%   Revision: 1.2  Data: 2011-07-26
%*************************************************************************


tStart = tic();
%*************************************************************************
% Verify the optimization model
%*************************************************************************
opt = verifyOpt(opt);

%*************************************************************************
% variables initialization
%*************************************************************************
nVar    = opt.numVar;
nObj    = opt.numObj;
nCons   = opt.numCons;
popsize = opt.popsize;

% pop : current population
% newpop : new population created by genetic algorithm operators
% combinepop = pop + newpop;
pop = repmat( struct(...
    'var', zeros(1,nVar), ...
    'obj', zeros(1,nObj), ...
    'cons', zeros(1,nCons),...
    'rank', 0,...
    'distance', 0,...
    'prefDistance', 0,...       % preference distance used in R-NSGA-II
    'nViol', 0,...
    'violSum', 0),...
    [1,popsize]);

% state: optimization state of one generation
state = struct(...
'currentGen', 1,...         % current generation number
'evaluateCount', 0,...      % number of objective function evaluation
'totalTime', 0,...          % total time from the beginning
'firstFrontCount', 0,...    % individual number of first front
'frontCount', 0,...         % number of front
'avgEvalTime', 0 ...        % average evaluation time of objective function (current generation)
);

result.pops     = repmat(pop, [opt.maxGen, 1]);     % each row is the population of one generation
result.states   = repmat(state, [opt.maxGen, 1]);   % each row is the optimizaiton state of one generation
result.opt      = opt;                              % use for output

% global variables
global STOP_NSGA;   %STOP_NSGA : used in GUI , if STOP_NSGA~=0, then stop the optimizaiton
STOP_NSGA = 0;


%*************************************************************************
% initialize the P0 population
%*************************************************************************
ngen = 1;
pop          = opt.initfun{1}(opt, pop, opt.initfun{2:end});
% pop          = load(strcat('NSGAII\',opt.OptName,'\Final_pop\Final_pop',num2str(ngen), '.mat').pop;
[pop, state] = evaluate(opt, pop, state, varargin{:});
[opt, pop]   = ndsort(opt, pop);

% state
state.currentGen  = ngen;
state.totalTime   = toc(tStart);
state             = statpop(pop, state);

result.pops(1, :) = pop;
result.states(1)  = state;

% output
% plotnsga(result, ngen); % NON ERA COMMENTATO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
opt = callOutputfuns(opt, state, pop);

%*************************************************************************
% NSGA2 iteration
%*************************************************************************
while( ngen < opt.maxGen && STOP_NSGA==0)
    % 0. Display some information
	ngen = ngen+1;
    state.currentGen = ngen;
    fprintf('\n\n************************************************************\n');
    fprintf('*      Current generation %d / %d\n', ngen, opt.maxGen);
    fprintf('************************************************************\n');
    
    % 1. Create new population
    newpop = selectOp(opt, pop);
    newpop = crossoverOp(opt, newpop, state);
    newpop = mutationOp(opt, newpop, state);
    [newpop, state] = evaluate(opt, newpop, state, varargin{:});

    % 2. Combine the new population and old population : combinepop = pop + newpop
    combinepop = [pop, newpop];
    
    % 3. Fast non dominated sort
    [opt, combinepop] = ndsort(opt, combinepop);
    
    % 4. Extract the next population
    pop = extractPop(opt, combinepop);
%     save(strcat('NSGAII\',opt.OptName,'\Final_pop\Final_pop',num2str(ngen), '.mat'), 'pop');
    save(strcat('NSGA\Final_pop\Final_pop',num2str(ngen), '.mat'), 'pop');

%     %% Current Population Analysis
%     % Objective functions trend
%     obj_fcn_name = {'yaw rate overshoot', 'response time', 'ay max1', 'ay max2', 'USG', 'beta grad', 'phase delay', 'ay max3', 'max dist', 'ax min'};
% 
%     for idx = 1:length(obj_fcn_name)
%         figure(idx)
%         plot(sort(pop.obj{1:opt.popsize,idx}), 'LineWidth', 2)
%         title(obj_fcn_name{idx})
%     end
% 
%     % Design variables trend        AGGIUNGERE A PIACERE
%     nbins = 20;
% 
%     figure(length(obj_fcn_name)+1)
% 
%     %% front
%     subplot(2,13,1)
%     edges = linspace(opt.lb(1), opt.ub(1), nbins);
%     histogram(pop.var,edges)
%     legend('rch_f')
%     xlim([opt.lb(1), opt.ub(1)])
%     
%     subplot(2,13,2)
%     edges = linspace(opt.lb(2), opt.ub(2), nbins);
%     histogram(pop(:,2),edges)
%     legend('FVSA_f')
%     xlim([opt.lb(2), opt.ub(2)])
%     
%     subplot(2,13,3)
%     edges = linspace(opt.lb(3), opt.ub(3), nbins);
%     histogram(pop(:,3),edges)
%     legend('aKingPin_f')
%     xlim([opt.lb(3), opt.ub(3)])
%     
%     subplot(2,13,4)
%     edges = linspace(opt.lb(4), opt.ub(4), nbins);
%     histogram(pop(:,4),edges)
%     legend('SR_f')
%     xlim([opt.lb(4), opt.ub(4)])
%     
%     subplot(2,13,5)
%     edges = linspace(opt.lb(5), opt.ub(5), nbins);
%     histogram(pop(:,5),edges)
%     legend('zUBJ_f')
%     xlim([opt.lb(5), opt.ub(5)])
%     
%     subplot(2,13,6)
%     edges = linspace(opt.lb(6), opt.ub(6), nbins);
%     histogram(pop(:,6),edges)
%     legend('zLBJ_f')
%     xlim([opt.lb(6), opt.ub(6)])
%     
%     subplot(2,13,7)
%     edges = linspace(opt.lb(7), opt.ub(7), nbins);
%     histogram(pop(:,7),edges)
%     legend('aCaster_f')
%     xlim([opt.lb(7), opt.ub(7)])
%     
%     subplot(2,13,8)
%     edges = linspace(opt.lb(8), opt.ub(8), nbins);
%     histogram(pop(:,8),edges)
%     legend('CT_f')
%     xlim([opt.lb(8), opt.ub(8)])
%     
%     subplot(2,13,9)
%     edges = linspace(opt.lb(9), opt.ub(9), nbins);
%     histogram(pop(:,9),edges)
%     legend('SVSA_f')
%     xlim([opt.lb(9), opt.ub(9)])
%     
%     subplot(2,13,10)
%     edges = linspace(opt.lb(10), opt.ub(10), nbins);
%     histogram(pop(:,10),edges)
%     legend('phi_f')
%     xlim([opt.lb(10), opt.ub(10)])
%     
%     subplot(2,13,11)
%     edges = linspace(opt.lb(11), opt.ub(11), nbins);
%     histogram(pop(:,11),edges)
%     legend('xTRO_f')
%     xlim([opt.lb(11), opt.ub(11)])
%     
%     subplot(2,13,12)
%     edges = linspace(opt.lb(12), opt.ub(12), nbins);
%     histogram(pop(:,12),edges)
%     legend('zTRO_f')
%     xlim([opt.lb(12), opt.ub(12)])
%     
%     subplot(2,13,13)
%     edges = linspace(opt.lb(13), opt.ub(13), nbins);
%     histogram(pop(:,13),edges)
%     legend('beta_f')
%     xlim([opt.lb(13), opt.ub(13)])
%     
%     %% rear
%     subplot(2,13,14)
%     edges = linspace(opt.lb(18), opt.ub(18), nbins);
%     histogram(pop(:,18),edges)
%     legend('rch_r')
%     xlim([opt.lb(18), opt.ub(18)])
%     
%     subplot(2,13,15)
%     edges = linspace(opt.lb(19), opt.ub(19), nbins);
%     histogram(pop(:,19),edges)
%     legend('FVSA_r')
%     xlim([opt.lb(19), opt.ub(19)])
%     
%     subplot(2,13,16)
%     edges = linspace(opt.lb(20), opt.ub(20), nbins);
%     histogram(pop(:,20),edges)
%     legend('aKingPin_r')
%     xlim([opt.lb(20), opt.ub(20)])
%     
%     subplot(2,13,17)
%     edges = linspace(opt.lb(21), opt.ub(21), nbins);
%     histogram(pop(:,21),edges)
%     legend('SR_r')
%     xlim([opt.lb(21), opt.ub(21)])
%     
%     subplot(2,13,18)
%     edges = linspace(opt.lb(22), opt.ub(22), nbins);
%     histogram(pop(:,22),edges)
%     legend('zUBJ_r')
%     xlim([opt.lb(22), opt.ub(22)])
%     
%     subplot(2,13,19)
%     edges = linspace(opt.lb(23), opt.ub(23), nbins);
%     histogram(pop(:,23),edges)
%     legend('zLBJ_r')
%     xlim([opt.lb(23), opt.ub(23)])
%     
%     subplot(2,13,20)
%     edges = linspace(opt.lb(24), opt.ub(24), nbins);
%     histogram(pop(:,24),edges)
%     legend('aCaster_r')
%     xlim([opt.lb(24), opt.ub(24)])
%     
%     subplot(2,13,21)
%     edges = linspace(opt.lb(25), opt.ub(25), nbins);
%     histogram(pop(:,25),edges)
%     legend('CT_r')
%     xlim([opt.lb(25), opt.ub(25)])
%     
%     subplot(2,13,22)
%     edges = linspace(opt.lb(26), opt.ub(26), nbins);
%     histogram(pop(:,26),edges)
%     legend('SVSA_r')
%     xlim([opt.lb(26), opt.ub(26)])
%     
%     subplot(2,13,23)
%     edges = linspace(opt.lb(27), opt.ub(27), nbins);
%     histogram(pop(:,27),edges)
%     legend('phi_r')
%     xlim([opt.lb(27), opt.ub(27)])
%     
%     subplot(2,13,24)
%     edges = linspace(opt.lb(28), opt.ub(28), nbins);
%     histogram(pop(:,28),edges)
%     legend('xTRO_r')
%     xlim([opt.lb(28), opt.ub(28)])
%     
%     subplot(2,13,25)
%     edges = linspace(opt.lb(29), opt.ub(29), nbins);
%     histogram(pop(:,29),edges)
%     legend('yTRO_r')
%     xlim([opt.lb(29), opt.ub(29)])
%     
%     subplot(2,13,26)
%     edges = linspace(opt.lb(30), opt.ub(30), nbins);
%     histogram(pop(:,30),edges)
%     legend('zTRO_r')
%     xlim([opt.lb(30), opt.ub(30)])


    % 5. Save current generation results
    state.totalTime = toc(tStart);
    state = statpop(pop, state);
    
    result.pops(ngen, :) = pop;
    result.states(ngen)  = state;

    % 6. plot current population and output
%     if( mod(ngen, opt.plotInterval)==0 )
%         plotnsga(result, ngen);
%     end % NON ERA COMMENTATO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if( mod(ngen, opt.outputInterval)==0 )
        opt = callOutputfuns(opt, state, pop);
    end
    
end

% call output function for closing file
opt = callOutputfuns(opt, state, pop, -1);

% close worker processes
if( strcmpi(opt.useParallel, 'yes'))
    parpool close
end

toc(tStart);


